def _create_response_json_content(self):
        content = self.response
        logging.info(f"Processing contents: {content}")

        if self._process_result(content):
            return

        if self._process_join(content):
            return

        if self._process_begin(content):
            return

        if self._process_start(content):
            return

        if self._process_board(content):
            return

    def _process_result(self, content):
        """Handle 'result' key in the response."""
        result = content.get("result")
        if result:
            print(f"\n\ngot result: {result}\n\n")
            if "Connection closing" in result:
                self.quit = True
            return True
        return False

    def _process_join(self, content):
        """Handle 'join' key in the response."""
        username = content.get(Action.JOIN.value)
        if username:
            self.join_a_username(username)
            return True
        return False

    def _process_begin(self, content):
        """Handle 'begin' key in the response."""
        value = content.get(Action.BEGIN.value)
        if value == Status.WAITING.value:
            logging.info("Ack: Still waiting...")
            return True
        return False

    def _process_start(self, content):
        """Handle the start action."""
        value = content.get(Action.START.value)
        if value:
            values = value.split(',')
            logging.info(f"Comparing {values[0]} to {self.username}.")
            self.color = Color.RED.value if self.isUserTurn else Color.BLACK.value
            self.gameStatus = Status.BEGIN
            self.boardID = values[1]
            return True
        return False

    def _process_board(self, content):
        if list(content.keys())[0] == Action.BOARD.value:
            values = content[Action.BOARD.value]

            if len(values) > len(self.moveHistory):
                self.gameBoard = Board.build_board(values)  # Translate raw string into numpy array
                self.moveHistory = values  # Update history to current history
                self.isUserTurn = True  # The other player made a move, it is now the user's turn
                logging.info("Board was updated. Updating local board to match server.")
            elif len(values) == 0:
                self.gameStatus = Status.ONGOING

            if self.gameStatus == Status.BEGIN.value:
                self.gameStatus = Status.ONGOING

            print("\n\n\n\n\n\n", numpy.matrix(self.gameBoard), "current turn:")
            return True
        return False          

    def join_a_username(self, result):
        print(f"\n\nPlease join an existing game:\n\n")
        username = self.response['join']
        if username == "No games available.":
            return
        self.state.set_possible_joins(self.response['join'])
        print(self.state.get_possible_joins())

def create_new_request(self):
        logging.info("Creating a new request...")
        previous_request = self.request["content"]["action"]
        possible_actions = self.state.get_next_states(previous_request)
        next_action = ""
        try:
            while not next_action and not self.quit: #  and not self.gameStatus
                """while we dont have a valid action and we aren't quitting
                if possible actions are empty, it means we tried to join when theres nothing to join
                if the next action is valid, set it as the action to be taken
                if the previous action was start, they need to wait for someone to join
                send periodic request from server to see if anyone joined
                if previous action was to join, and it was sucessful, they need to 
                begin the game state
                """
                if not possible_actions:
                    possible_actions = self.state.no_join()
                    print("\n\nNo open games available!")
                    self.request["content"]["action"] = "None"
                print(f"\n\nPlease select an action to take!\n"
                      + f"Possible actions: {possible_actions}")
                logging.info(f"Before request contents: {self.request}")
                next_action = input()
                if next_action in possible_actions:
                    self.request["content"]["action"] = next_action
                    if next_action == Action.START.value:
                        self.gameStatus = Status.WAITING
                        self.isUserTurn = True
                        self.request["content"]["value"] = self.username
                        self.queue_request()
                        self._request_queued = True
                        self._set_selector_events_mask("rw")
                    if previous_request == Action.JOIN.value:
                        self.gameStatus = Status.WAITING
                        self.isUserTurn = False
                        self.request["content"]["value"] = f"{next_action},{self.username}"
                        self.request["content"]["action"] = "begin"
                        self.queue_request()
                        self._request_queued = True
                        self._set_selector_events_mask("rw")
                        
                # elif next_action in self.state.get_possible_joins():
                #     username = self.request["content"]["value"]
                #     self.request["content"]["value"] = f"{self.username},{next_action}"
                #     self.request["content"]["action"] = "begin"
                #     self.queue_request()
                #     self._request_queued = True
                #     self._set_selector_events_mask("rw")
                else:
                    next_action = ""

                logging.info(f"After request contents: {self.request}")        
        except Exception as err:
            logging.exception(f"Exception: Uncaught error.\n{err}")
        if not self.gameStatus:
            self.queue_request()
            self._request_queued = True
            self._set_selector_events_mask("rw")

    def legal_move(self, move):
        if not move:
            return False

        if (len(move) == 3
            and move[0] == 'a' or move[0] == 'b'
            and 0 <= move[1] <= 6
            and 0 <= move[2] <= 7):
            return True
        return False

    def process_events(self, mask):
        logging.info(f"Process events occurring for user {self.username}")

        if mask & selectors.EVENT_READ:
            self.read()
        if mask & selectors.EVENT_WRITE:
            self.write()
        
        #create another event read, if theres nothing queued and no response waiting
        logging.debug(f"Current game status is {self.gameStatus}")
        
        if self.gameStatus == Status.WAITING:
            time.sleep(0.1)
            logging.debug("Status waiting, seeing if player has joined lobby...\n\n\n\n\n")
            self.request = fill_text_request("begin", Status.WAITING.value+self.username)
            self.queue_request()
            # self._request_queued = True
            self._set_selector_events_mask("rw")
        elif self.gameStatus == Status.BEGIN:
            self.request = fill_text_request(Action.BOARD.value, self.boardID)
            self.queue_request()
            # self._request_queued = True
            self._set_selector_events_mask("rw")
        elif self.gameStatus == Status.ONGOING:
            if self.isUserTurn:

                move = ""
                while not move:
                    move = input()
                    if not self.legal_move(move):
                        move = ""

                logging.info(f"Player made move {move}.")
                self.request = fill_text_request(Action.MOVE.value, f"{self.username},{self.color},{move},{self.boardID}")
                self.queue_request()
                self._request_queued = True
                self._set_selector_events_mask("rw")
                self.isUserTurn = False
                logging.info(f"Client made move. Informing Server. No longer this user's turn.")
            else:
                time.sleep(1)
                logging.info("Waiting for other client to give move...")
                self.request = fill_text_request("board", self.boardID)
                self.queue_request()
                self._request_queued = True
                self._set_selector_events_mask("rw")

        elif not self.response and not self._request_queued:
            self.create_new_request()
            
        if not self._recv_buffer and self._send_buffer and self.quit:
            self.close()